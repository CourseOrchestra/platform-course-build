<!DOCTYPE html>
<html lang="en">
  <head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Лучшие практики написания кода Celesta :: Платформа КУРС</title>
    <meta name="generator" content="Antora 3.0.0">
    <link rel="stylesheet" href="../../_/css/site.css">
    <script>var uiRootPath = '../../_'</script>
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="../..">Платформа КУРС</a>
      <div class="navbar-item search hide-for-print">
        <div id="search-field" class="field">
          <input id="search-input" type="text" placeholder="Поиск">
        </div>
      </div>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="../../index.html"><img src="../../_/img/course-orchestra-logo.svg" width="60rem"></a>
        <!--div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Products</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Product A</a>
            <a class="navbar-item" href="#">Product B</a>
            <a class="navbar-item" href="#">Product C</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Services</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Service A</a>
            <a class="navbar-item" href="#">Service B</a>
            <a class="navbar-item" href="#">Service C</a>
          </div>
        </div>
        <div class="navbar-item">
          <span class="control">
            <a class="button is-primary" href="#">Download</a>
          </span>
        </div-->
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="celesta" data-version="7">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="1010_what_is_celesta.html">Челеста</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="1010_what_is_celesta.html">Что такое Celesta?</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="1012_demo.html">Демонстрационный пример</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="1013_maven_plugin.html">Maven-плагин</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="1015_vocabulary.html">Словарь основных понятий Celesta</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="1020_celesta_start.html">Операции, выполняемые при инициализации Celesta</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="1030_basic_settings.html">Параметры конфигурации Celesta</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="1040_system_tables.html">Системные таблицы Celesta</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="1050_celesta_sql.html">Язык Celesta-SQL</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="1060_celesta_doc.html">CelestaDoc</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="1065_celesta_instantiation.html">Создание экземпляра Celesta</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="1070_call_context.html">Контекст вызова</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="1080_data_accessors.html">Работа с данными через классы доступа к данным (курсоры)</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="1088_security_logging.html">Распределение прав доступа и протоколирование изменений</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="1090_blob.html">BLOB-поля</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="1100_option.html">Options-поля</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="1102_dynamic.html">Динамический доступ к данным</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="1105_triggers.html">Триггеры</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="1107_xrec.html">Объект xRec</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="1110_lost_updates_protection.html">Защита от потерянных обновлений</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="1120_meta.html">Метаданные Celesta</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="1130_celesta_unit.html">CelestaUnit</a>
  </li>
  <li class="nav-item is-current-page" data-depth="1">
    <a class="nav-link" href="2005_best_practices.html">Лучшие практики написания кода Celesta</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="2010_supported_rdbms.html">Особенности работы Celesta с поддерживаемыми типами СУБД</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="2020_dbschema.html">Проектирование базы данных Celesta в DBSchema</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Челеста</span>
    <span class="version">7</span>
  </div>
  <ul class="components">
    <li class="component">
      <a class="title" href="../../mellophone/2/general.html">Мелофон</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../mellophone/2/general.html">2</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../../doc/1/st2-ui-state-in-url.html">Платформа КУРС</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../doc/1/st2-ui-state-in-url.html">1</a>
        </li>
      </ul>
    </li>
    <li class="component is-current">
      <a class="title" href="1010_what_is_celesta.html">Челеста</a>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="1010_what_is_celesta.html">7</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../../doc/1/general.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="1010_what_is_celesta.html">Челеста</a></li>
    <li><a href="2005_best_practices.html">Лучшие практики написания кода Celesta</a></li>
  </ul>
</nav>
<!--  -->
<!--  -->
<!--  <div class="edit-this-page"><a href="file:///usr/src/app/target/doc/components/celesta/target/antora/modules/ROOT/pages/2005_best_practices.adoc">Редактировать страницу</a></div>-->
<!--  -->
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Содержание" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Лучшие практики написания кода Celesta</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Следующие советы позволят избежать некоторых распространённых ошибок при написании кода, работающего с СУБД, с использованием Celesta, а также описывают ряд зарекомендовавших себя паттернов.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_явно_закрывайте_курсоры_создаваемые_в_цикле">
<a class="anchor" href="#_%D1%8F%D0%B2%D0%BD%D0%BE_%D0%B7%D0%B0%D0%BA%D1%80%D1%8B%D0%B2%D0%B0%D0%B9%D1%82%D0%B5_%D0%BA%D1%83%D1%80%D1%81%D0%BE%D1%80%D1%8B_%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%B2%D0%B0%D0%B5%D0%BC%D1%8B%D0%B5_%D0%B2_%D1%86%D0%B8%D0%BA%D0%BB%D0%B5"></a>1. Явно закрывайте курсоры, создаваемые в цикле</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Курсор — объект, заключающий в себе JDBC PreparedStatements и ResultSets, необходимые для выполнения методов курсора.
Эти ресурсы необходимо закрывать после использования.
Кроме того, ни сам курсор, ни объекты, составляющие его внутреннее состояние, не являются потокобезопасными, поэтому нельзя хранить курсор в виде разделяемого ресурса.
Закрытие курсора, утеря ссылки на него и завершение транзакции — события, которые в норме должны происходить одновременно.</p>
</div>
<div class="paragraph">
<p>Время жизни курсора ограничено временем жизни <code>CallContext</code>, с помощью которого он был создан.
Вызов метода <code>close()</code> на <code>CallContext</code> приводит к закрытию всех курсоров, созданных в этом контексте, поэтому обычно явно закрывать курсоры в коде не нужно.</p>
</div>
<div class="paragraph">
<p>Тем не менее, в ситуации, когда создание курсора может происходить в цикле, его следует явно закрывать.</p>
</div>
<div class="paragraph">
<p>CallContext <a href="1080_data_accessors.html#too_many_accessors_warning">не даст создать более 1023 курсоров</a> (иначе это может привести к ошибке на стороне базы данных).
Если курсор может создаваться в цикле, его следует закрывать (в следующем пункте код будет ещё улучшен):</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">ПЛОХО</th>
<th class="tableblock halign-center valign-top">НОРМАЛЬНО</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@CelestaTransaction
void doSomething(CallContext context) {
  for (int i = 0; i &lt; 2000; i++)
    doSomethingElse(context);
}

void doSomethingElse(CallContext context) {
  //Exception: too many data accessors
  FooCursor foo = new FooCursor (context);
}</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@CelestaTransaction
void doSomething(CallContext context) {
  for (int i = 0; i &lt; 2000; i++)
    doSomethingElse(context);
}

void doSomethingElse(CallContext context) {
  try(FooCursor foo = new FooCursor (context)){
  /*no exception thrown, but
  we can do better!*/
  }
}</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect1">
<h2 id="_избегайте_создания_курсора_в_цикле">
<a class="anchor" href="#_%D0%B8%D0%B7%D0%B1%D0%B5%D0%B3%D0%B0%D0%B9%D1%82%D0%B5_%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D1%8F_%D0%BA%D1%83%D1%80%D1%81%D0%BE%D1%80%D0%B0_%D0%B2_%D1%86%D0%B8%D0%BA%D0%BB%D0%B5"></a>2. Избегайте создания курсора в цикле</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Создание и закрытие курсора в цикле приводит к многократному созданию и закрытию JDBC PreparedStatements, что работает не эффективно.
Лучшим решением является дизайн кода, при котором курсоры создаются в самом начале сервисного метода и затем переиспользуются:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">НОРМАЛЬНО</th>
<th class="tableblock halign-center valign-top">ПРАВИЛЬНО</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@CelestaTransaction
void doSomething(CallContext context) {
  for (int i = 0; i &lt; 2000; i++)
    doSomethingElse(context);
}

void doSomethingElse(CallContext context) {
  try(FooCursor foo = new FooCursor (context)){
  /*no exception thrown, but
  we can do better!*/
  }
}</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@CelestaTransaction
void doSomething(CallContext context) {
  FooCursor foo = new FooCursor (context);
  for (int i = 0; i &lt; 2000; i++)
   doSomethingElse(foo);
}
void doSomethingElse(FooCursor foo) {
  /*now we do not create-and-close
  the cursor in each iteration*/
}</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect1">
<h2 id="_используйте_ограничение_количества_полей_в_курсоре">
<a class="anchor" href="#_%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B9%D1%82%D0%B5_%D0%BE%D0%B3%D1%80%D0%B0%D0%BD%D0%B8%D1%87%D0%B5%D0%BD%D0%B8%D0%B5_%D0%BA%D0%BE%D0%BB%D0%B8%D1%87%D0%B5%D1%81%D1%82%D0%B2%D0%B0_%D0%BF%D0%BE%D0%BB%D0%B5%D0%B9_%D0%B2_%D0%BA%D1%83%D1%80%D1%81%D0%BE%D1%80%D0%B5"></a>3. Используйте ограничение количества полей в курсоре</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Если в читаемой таблице много полей, но для работы метода нужны лишь некоторые из них — для ускорения работы следует воспользоваться <a href="1080_data_accessors.html#limit_columns">ограничением выборки полей</a>.
Это способно ощутимо сократить объём данных, передаваемых из базы.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_методы_не_обращающиеся_к_базе_данных_работают_быстро">
<a class="anchor" href="#_%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D1%8B_%D0%BD%D0%B5_%D0%BE%D0%B1%D1%80%D0%B0%D1%89%D0%B0%D1%8E%D1%89%D0%B8%D0%B5%D1%81%D1%8F_%D0%BA_%D0%B1%D0%B0%D0%B7%D0%B5_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85_%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D1%8E%D1%82_%D0%B1%D1%8B%D1%81%D1%82%D1%80%D0%BE"></a>4. Методы, не обращающиеся к базе данных, работают быстро</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Методы курсоров можно условно разделить на три категории:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Не обращающиеся к базе данных</th>
<th class="tableblock halign-left valign-top">Производящие чтение</th>
<th class="tableblock halign-left valign-top">Производящие обновление</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>установка/чтение полей</p>
</li>
<li>
<p><code>setRange</code></p>
</li>
<li>
<p><code>setFilter</code></p>
</li>
<li>
<p><code>setComplexFilter</code></p>
</li>
<li>
<p><code>setIn</code></p>
</li>
<li>
<p><code>limit</code></p>
</li>
<li>
<p><code>orderBy</code></p>
</li>
<li>
<p><code>reset</code></p>
</li>
<li>
<p><code>clear</code></p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p><code>[try]Get</code></p>
</li>
<li>
<p><code>[try]First</code></p>
</li>
<li>
<p><code>[try]Last</code></p>
</li>
<li>
<p><code>[try]FindSet</code></p>
</li>
<li>
<p><code>next</code></p>
</li>
<li>
<p><code>navigate</code></p>
</li>
<li>
<p><code>count</code></p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p><code>[try]Insert</code></p>
</li>
<li>
<p><code>[try]Update</code></p>
</li>
<li>
<p><code>delete</code></p>
</li>
<li>
<p><code>deleteAll</code></p>
</li>
</ul>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Вызов методов из первой категории не приводит к отправке никаких запросов к базе данных.
Например, <code>orderBy</code> не сортирует записи в момент вызова, <code>setRange</code> не фильтрует записи в момент вызова — они лишь формируют состояние курсора, которое будет использовано при формировании SQL-запросов при вызове методов из второй и третьей категории.</p>
</div>
<div class="paragraph">
<p>Таким образом, правильным паттерном является максимальная «подготовка курсора» через выставление всех необходимых ограничений методами из первой категории перед тем, как запускать методы чтения.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_понимайте_семантику_метода_get">
<a class="anchor" href="#_%D0%BF%D0%BE%D0%BD%D0%B8%D0%BC%D0%B0%D0%B9%D1%82%D0%B5_%D1%81%D0%B5%D0%BC%D0%B0%D0%BD%D1%82%D0%B8%D0%BA%D1%83_%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D0%B0_get"></a>5. Понимайте семантику метода get</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Метод <code>get(…​)</code> извлекает из базы данных одну запись по её известному первичному ключу.
Это гарантированно быстрая (за счёт обязательного наличия индекса на первичном ключе) и очень часто требующаяся на практике операция.
Метод <code>get(…​)</code> <em>не учитывает</em> наличие каких-либо фильтров на курсоре, поэтому в редком случае, когда надо проверить, попадает ли запись с известным ключом в набор, определённый фильтрами на текущем курсоре, следует воспользоваться методом <code>navigate("=")</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_не_производите_лишних_чтений_перед_удалением">
<a class="anchor" href="#_%D0%BD%D0%B5_%D0%BF%D1%80%D0%BE%D0%B8%D0%B7%D0%B2%D0%BE%D0%B4%D0%B8%D1%82%D0%B5_%D0%BB%D0%B8%D1%88%D0%BD%D0%B8%D1%85_%D1%87%D1%82%D0%B5%D0%BD%D0%B8%D0%B9_%D0%BF%D0%B5%D1%80%D0%B5%D0%B4_%D1%83%D0%B4%D0%B0%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%D0%BC"></a>6. Не производите лишних чтений перед удалением</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Если нам известен первичный ключ записи, которую мы хотим удалить, не нужно перед этим вычитывать её из базы данных с помощью <code>get</code> или <code>find</code>.
Методу <code>delete()</code> достаточно только того, чтобы поля первичного ключа были заполнены нужными значениями.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">ПЛОХО</th>
<th class="tableblock halign-center valign-top">ПРАВИЛЬНО</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">if (foo.tryGet(idForDeletion)) {
	foo.delete();
}</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">foo.setId(idForDeletion);
foo.delete();</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect1">
<h2 id="_не_используйте_count_только_для_того_чтобы_определить_что_набор_данных_не_пуст">
<a class="anchor" href="#_%D0%BD%D0%B5_%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B9%D1%82%D0%B5_count_%D1%82%D0%BE%D0%BB%D1%8C%D0%BA%D0%BE_%D0%B4%D0%BB%D1%8F_%D1%82%D0%BE%D0%B3%D0%BE_%D1%87%D1%82%D0%BE%D0%B1%D1%8B_%D0%BE%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B8%D1%82%D1%8C_%D1%87%D1%82%D0%BE_%D0%BD%D0%B0%D0%B1%D0%BE%D1%80_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85_%D0%BD%D0%B5_%D0%BF%D1%83%D1%81%D1%82"></a>7. Не используйте count() только для того, чтобы определить, что набор данных не пуст</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Часто встречающаяся ошибка — проверять набор записей «на пустоту» через метод <code>count()</code>.
Пересчитывать на стороне базы данных все записи для того, чтобы понять, что есть хотя бы одна — плохая идея.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">ПЛОХО</th>
<th class="tableblock halign-center valign-top">ПРАВИЛЬНО</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">if (fooCursor.count() &gt; 0) {
	...
}</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">if (fooCursor.tryFirst()) {
	...
}</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect1">
<h2 id="_пользуйтесь_сортировкой_на_уровне_базы_данных_для_того_чтобы_найти_минимальныемаксимальные_значения">
<a class="anchor" href="#_%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B9%D1%82%D0%B5%D1%81%D1%8C_%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%BE%D0%B9_%D0%BD%D0%B0_%D1%83%D1%80%D0%BE%D0%B2%D0%BD%D0%B5_%D0%B1%D0%B0%D0%B7%D1%8B_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85_%D0%B4%D0%BB%D1%8F_%D1%82%D0%BE%D0%B3%D0%BE_%D1%87%D1%82%D0%BE%D0%B1%D1%8B_%D0%BD%D0%B0%D0%B9%D1%82%D0%B8_%D0%BC%D0%B8%D0%BD%D0%B8%D0%BC%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5%D0%BC%D0%B0%D0%BA%D1%81%D0%B8%D0%BC%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5_%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8F"></a>8. Пользуйтесь сортировкой на уровне базы данных для того, чтобы найти минимальные/максимальные значения</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Если поиск одного значения можно выполнить в самой базе данных — это гораздо предпочтительнее, чем передавать весь набор записей в приложение, чтобы выполнять поиск средствами приложения:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">ПЛОХО</th>
<th class="tableblock halign-left valign-top">ПРАВИЛЬНО</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Цикл по записям с целью поиска  максимального значения поля <code>bar</code>.</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">foo.orderBy(foo.COLUMNS.bar().desc());
foo.first();</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect1">
<h2 id="_используйте_правильный_тип_фильтрации">
<a class="anchor" href="#_%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B9%D1%82%D0%B5_%D0%BF%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D1%82%D0%B8%D0%BF_%D1%84%D0%B8%D0%BB%D1%8C%D1%82%D1%80%D0%B0%D1%86%D0%B8%D0%B8"></a>9. Используйте правильный тип фильтрации</h2>
<div class="sectionbody">
<div class="paragraph">
<p>В Celesta имеется четыре метода фильтрации данных, по мере роста сложности:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>setRange</code></p>
</li>
<li>
<p><code>setFilter</code></p>
</li>
<li>
<p><code>setComplexFilter</code></p>
</li>
<li>
<p><code>setIn</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Не используйте более сложный фильтр, если можно обойтись более простым!</strong></p>
</div>
<div class="paragraph">
<p>Метод <a href="1080_data_accessors.html#set_range_usage"><code>setRange</code></a> закрывает большинство практических задач, когда поле необходимо фильтровать по единственному значению или диапазону значений:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>cursor.setRange(cursor.COLUMNS.foo(), value)</code> порождает запрос вида <code>WHERE foo = value</code>.</p>
</li>
<li>
<p><code>cursor.setRange(cursor.COLUMNS.foo(), from, to)</code> порождает запрос вида <code>WHERE foo BETWEEN from AND to</code></p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Замечание"></i>
</td>
<td class="content">
<code>cursor.setRange(cursor.COLUMNS.foo())</code> (без параметров) убирает фильтр на поле “foo”, ранее заданный как с помощью <code>setRange</code>, так и с помощью <code>setFilter</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Метод <a href="1080_data_accessors.html#setFilter_usage"><code>setFilter</code></a> нужен для более редко встречающихся случаев, когда множество значений поля, по которым осуществляется фильтрация, необходимо задать сложным выражением.
На одном поле может быть либо фильтр, заданный <code>setRange</code>, либо фильтр, заданный <code>setFilter</code>, поэтому вызов этих методов для одного и того же поля «вытесняет» заданный ранее фильтр.</p>
</div>
<div class="paragraph">
<p>Следует применять <code>setRange</code> там, где это возможно, т. к. в этом случае Celesta имеет возможность переиспользовать JDBC <code>PreparedStatement</code>-ы, что существенно улучшает быстродействие при работе в цикле:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">ПЛОХО</th>
<th class="tableblock halign-center valign-top">ПРАВИЛЬНО</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">FooCursor foo = new FooCursor(context);
BarCursor bar = new BarCursor(context);
for (FooCursor c: foo){
  bar.setFilter("baz", "’"+c.getBaz()+"’");
  /* PreparedStatements are
  re-created in each iteration :-(( */
  ...
}</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">FooCursor foo = new FooCursor(context);
BarCursor bar = new BarCursor(context);
for (FooCursor c: foo){
  bar.setRange(“baz”, c.getBaz());
  /* PreparedStatement is created
  only once and is being reused :-)*/
}</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><code>setRange</code> предпочтительнее ещё и потому, что его API позволяет осуществлять контроль типов, передаваемых в качестве аргументов этого метода.</p>
</div>
<div class="paragraph">
<p>Метод <a href="1080_data_accessors.html#set_complex_filter_usage"><code>setComplexFilter</code></a> позволяет добавить «кусок SQL» в <code>WHERE</code>-выражение, задающее набор записей курсора.
После любого вызова <code>setComplexFilter</code> все JDBC <code>PreparedStatement</code>-ы должны пересоздаваться заново, поэтому вызывать его в цикле, как и <code>setFilter</code>, неэффективно.
Основное применение этого метода — для того, чтобы задавать условия между полями, например: <code>a &gt;= b</code>.
В остальных случаях подходят <code>setRange</code>/<code>setFilter</code>.</p>
</div>
<div class="paragraph">
<p>Метод <a href="1080_data_accessors.html#setIn_usage"><code>setIn</code></a> требуется в ситуациях, когда набор фильтруемых значений определяется динамически из других данных в базе.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_применяйте_индексы">
<a class="anchor" href="#_%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D1%8F%D0%B9%D1%82%D0%B5_%D0%B8%D0%BD%D0%B4%D0%B5%D0%BA%D1%81%D1%8B"></a>10. Применяйте индексы</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Общий момент, касающийся любой работы с реляционными СУБД.
В случае с Celesta, простым первым приближением является следующее: если на поле курсора вызывается метод <code>setRange</code> — на данное поле следует создать индекс.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_эффективно_кэшируйте_значения_при_работе_в_циклах">
<a class="anchor" href="#_%D1%8D%D1%84%D1%84%D0%B5%D0%BA%D1%82%D0%B8%D0%B2%D0%BD%D0%BE_%D0%BA%D1%8D%D1%88%D0%B8%D1%80%D1%83%D0%B9%D1%82%D0%B5_%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8F_%D0%BF%D1%80%D0%B8_%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B5_%D0%B2_%D1%86%D0%B8%D0%BA%D0%BB%D0%B0%D1%85"></a>11. Эффективно кэшируйте значения при работе в циклах</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Запрос данных в цикле — довольно часто встречающийся паттерн.
В этом случае количество запросов к базе данных можно существенно сократить, а скорость увеличить, если применить самое простое кэширование: не надо вызывать <code>get</code> для курсора, если запрашиваемое значение первичного ключа уже соответствует тому, что было вызвано ранее:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">//mind possible nulls!
if (!Objects.equals(bar.getId(), c.getBarId()))
		bar.get(c.getBarId());
//use newly fetched or cached bar here...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Эту идею можно развить в очень эффективный паттерн: за счёт сортировки по курсора <code>c</code> по полю <code>barId</code> можно свести количество обращений в базу данных за записями <code>bar</code> к минимуму:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">ПЛОХО</th>
<th class="tableblock halign-center valign-top">ПРАВИЛЬНО</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">FooCursor foo = new FooCursor(context);
BarCursor bar = new BarCursor(context);
for (FooCursor c: foo){
  bar.get(c.getBarId());
/*fetching data
  in each iteration :-(*/
}</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">FooCursor foo = new FooCursor(context);
/*note the orderBy!!!*/
foo.orderBy(foo.COLUMNS.barId());
BarCursor bar = new BarCursor(context);
for (FooCursor c: foo){
  if (!Objects.equals(bar.getId(), c.getBarId()))
	/*minimum number of fetches*/
	bar.get(c.getBarId());
}</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect1">
<h2 id="_не_используйте_try_методы_без_необходимости">
<a class="anchor" href="#_%D0%BD%D0%B5_%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B9%D1%82%D0%B5_try_%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D1%8B_%D0%B1%D0%B5%D0%B7_%D0%BD%D0%B5%D0%BE%D0%B1%D1%85%D0%BE%D0%B4%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B8"></a>12. Не используйте try-методы без необходимости</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Многие методы курсора имеют два варианта: без приставки <code>try</code> и c приставкой <code>try</code>.
С точки зрения быстродействия они работают одинаково, с точки зрения дизайна кода (fail-fast подход) предпочтительнее использовать методы без <code>try</code>, если вы не собираетесь использовать возвращаемое булевское значение.
Этот момент <a href="1080_data_accessors.html#try_method_notice">разъяснён в документации</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_в_циклах_используйте_итерацию_вместо_навигации">
<a class="anchor" href="#_%D0%B2_%D1%86%D0%B8%D0%BA%D0%BB%D0%B0%D1%85_%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B9%D1%82%D0%B5_%D0%B8%D1%82%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D1%8E_%D0%B2%D0%BC%D0%B5%D1%81%D1%82%D0%BE_%D0%BD%D0%B0%D0%B2%D0%B8%D0%B3%D0%B0%D1%86%D0%B8%D0%B8"></a>13. В циклах используйте итерацию вместо навигации</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Для перемещения по записям в курсоре существуют две группы методов: навигационные и итерационные.</p>
</div>
<div class="paragraph">
<p>К навигационным относятся <code>tryFirst()</code>, <code>next()</code>, <code>previous()</code> и <code>navigate(…​)</code>, позволяющие переместиться на другую запись относительно текущей по определённым правилам.</p>
</div>
<div class="paragraph">
<p>К итерационным относятся пара методов <code>tryFindSet()</code> — <code>nextInSet()</code>, а также метод <code>iterator()</code>, реализующий соответствующий метод интерфейса <code>java.lang.Iterable</code>.</p>
</div>
<div class="paragraph">
<p>Навигационные методы отправляют по одному запросу в базу данных при каждом вызове, и поэтому их следует использовать лишь в тех случаях, когда нам требуется одна запись.</p>
</div>
<div class="paragraph">
<p>Итерационные методы отправляют запрос и открывают JDBC <code>ResultSet</code>, используемый в дальнейшем для перехода по записям.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">ПЛОХО</th>
<th class="tableblock halign-center valign-top">ПРАВИЛЬНО</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">if (foo.tryFirst()){
  do {
     ...
  } while (foo.next());
  /*new query in each iteration :-(*/
}</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">/*only one query! :-)*/
for (FooCursor c: foo) {
  ...
}</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
</div>
</div>
</article>
  </div>
</main>
</div>
<script id="site-script" src="../../_/js/site.js" data-ui-root-path="../../_"></script>
<script async src="../../_/js/vendor/highlight.js"></script>
<script src="../../_/js/vendor/lunr.js"></script>
<script src="../../_/js/vendor/lunr-languages.js"></script>
<script src="../../_/js/search-ui.js" id="search-ui-script" data-site-root-path="../.." data-snippet-length="100" data-stylesheet="../../_/css/search.css"></script>
<script async src="../../search-index.js"></script>
  </body>
</html>
